import{_ as a,o as e,c as n,U as s}from"./chunks/framework.3eb667f5.js";const b=JSON.parse('{"title":"Linux命令","description":"","frontmatter":{},"headers":[],"relativePath":"study/questions/linux.md","lastUpdated":1681131075000}'),t={name:"study/questions/linux.md"},o=s(`<h1 id="linux命令" tabindex="-1">Linux命令 <a class="header-anchor" href="#linux命令" aria-label="Permalink to &quot;Linux命令&quot;">​</a></h1><h2 id="_1-删除当前文件夹文件-不删除子目录文件" tabindex="-1">1.删除当前文件夹文件，不删除子目录文件 <a class="header-anchor" href="#_1-删除当前文件夹文件-不删除子目录文件" aria-label="Permalink to &quot;1.删除当前文件夹文件，不删除子目录文件&quot;">​</a></h2><div class="language- line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">find . -maxdepth 1 -type f | xargs rm</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;">-maxdepth 1 限制深度为1的查找，避免删除子目录文件。</span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span>
<span class="line"><span style="color:#A6ACCD;"></span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="_2-部署golang" tabindex="-1">2.部署golang <a class="header-anchor" href="#_2-部署golang" aria-label="Permalink to &quot;2.部署golang&quot;">​</a></h2><p>1.在linux环境换编译代码<br><code>CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags &quot;-s -w&quot; main.go</code><br> 2.运行项目<br><code>nohup ./xxx.sh &gt;log.txt 2&gt;&amp;1 &amp; </code><br> 后台运行文件，并将日志保存到log文件中，&gt;log.txt覆盖源文件，&gt;&gt;log.txt追加源文件</p><h2 id="命令详解" tabindex="-1">命令详解： <a class="header-anchor" href="#命令详解" aria-label="Permalink to &quot;命令详解：&quot;">​</a></h2><h3 id="后台运行" tabindex="-1">&amp; 后台运行 <a class="header-anchor" href="#后台运行" aria-label="Permalink to &quot;&amp; 后台运行&quot;">​</a></h3><p>命令 参数 &amp;：在原有的命令和参数后面加空格&amp;，此时当有日志时仍然会输出到屏幕，但进程会在后台运行，我们在前台仍然可以执行其他命令。只是关闭putty终端后该进程还是会结束，而且我们并不想在前台看到那些日志。</p><h3 id="nohup始终运行" tabindex="-1">nohup始终运行 <a class="header-anchor" href="#nohup始终运行" aria-label="Permalink to &quot;nohup始终运行&quot;">​</a></h3><p>nohup 命令 参数：nohup 的位置在命令的前面，即使关闭putty终端该进程仍然会继续执行，其日志不会输出到前台，而是记录在当前目录的nohup.out文件中。没有&amp;默认情况是在前台执行，所以前台被占用也无法输入其他命令，而且ctrl+c仍然会结束当前前台程序。</p><h3 id="nohup-结合" tabindex="-1">nohup 结合 &amp; <a class="header-anchor" href="#nohup-结合" aria-label="Permalink to &quot;nohup 结合 &amp;&quot;">​</a></h3><p>nohup 命令 参数 &amp;：当两者结合使用时，进程会在后台始终运行，关闭putty终端或在前台ctrl+c都不会关闭，日志输出到nohup.out。</p><p>命令示例： nohup 命令 参数 &amp;</p><blockquote><p>输出文件 假如我们不想把日志输出到nohup.out，而是想输出到test.out</p></blockquote><p>示例：nohup 命令 参数 &gt;test.out &amp;</p><h3 id="dev-null-黑洞设备" tabindex="-1">/dev/null 黑洞设备 <a class="header-anchor" href="#dev-null-黑洞设备" aria-label="Permalink to &quot;/dev/null 黑洞设备&quot;">​</a></h3><p>通常一些java框架如spring都会配置记录日志，我们并不需要linux来记录日志，而且时间长了nohup.out文件会变的非常大，所以我们把linux中的日志全部丢到/dev/null中，相当于垃圾桶，就不会再产生linux日志了。</p><p>示例：nohup 命令 参数 &gt;/dev/null &amp;</p><h3 id="_2-1错误输出" tabindex="-1">2&gt;&amp;1错误输出 <a class="header-anchor" href="#_2-1错误输出" aria-label="Permalink to &quot;2&gt;&amp;1错误输出&quot;">​</a></h3><p>有一种很流行的命令格式是：nohup 命令 参数 &gt;/dev/null 2&gt;&amp;1 &amp;，比上面多了个2&gt;&amp;1。2是错误信息输出 ，1是标准信息输出。&gt;/dev/null是将1放进黑洞， 2&gt;&amp;1是将2放进1，最终都进入黑洞。我们要搞清楚，2并不是程序运行时的异常日志，而是linux系统中的错误提示，比如nohup 命令中，这个命令我们输错，少打了一个字母，系统会立即给我们提示。而你加了 2&gt;&amp;1以后，这个错误提示就进入黑洞，你只能一脸茫然的干瞪眼。</p><h2 id="linux硬盘测速" tabindex="-1">Linux硬盘测速 <a class="header-anchor" href="#linux硬盘测速" aria-label="Permalink to &quot;Linux硬盘测速&quot;">​</a></h2><p>写速度：</p><p>time dd if=/dev/zero of=test.dbf bs=8k count=300000 其中/dev/zero是一个伪设备，它只产生空字符流，对它不会产生IO，所以，IO都会集中在of文件中，of文件只用于写，所以这个命令相当于测试磁盘的写能力。</p><p>输出的结果类似(因为一般更长测试时间更准确，所以可以设置count大一些)： 300000+0 records in 300000+0 records out</p><p>real 0m36.669s user 0m0.185s sys 0m9.340s</p><p>所以写速度为：8*300000/1024/36.669=63.916M/s</p><p>读速度：</p><p>time dd if=/dev/sda1 of=/dev/null bs=8k 因为/dev/sdb1是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，相当于黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb1上，也相当于测试磁盘的读能力</p><p>输出的结果类似： 448494+0 records in 448494+0 records out</p><p>real 0m51.070s user 0m0.054s sys 0m10.028s</p><p>所以sda1上的读取速度为：8*448494/1024/51.070=68.61M/s</p>`,31),l=[o];function p(r,u,i,d,h,c){return e(),n("div",null,l)}const x=a(t,[["render",p]]);export{b as __pageData,x as default};
